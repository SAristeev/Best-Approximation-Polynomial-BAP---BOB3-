#include <iostream>
#include <iomanip>
#include <fstream>
#include <vector>
#include <Dense>


using Eigen::MatrixXd;
using Eigen::VectorXd;

double f(double x) {
	//return pow(x - 1, 4) + pow(x - 3, 3) + pow(x - 2, 2) + 50 + 100 * sin(100 * x);
	return sin(x);
}

int main()
{
	double a = -2, b = 2; // начало и конец отрезка

	const int K = 10; // количество конечных элементов
	const int N = 6; // количество узлов на 1 конечном элементе
	const int L = 40; // количество случайных точек
	const int M_ = K * N; // количество базисных (склееных) функций

	const int M = K * (N - 1) + 1; // количество базисных (склееных) функций, оно же количество узлов
	double h = (b - a) / (M - 1); // шаг по равномерной сетке

	double mesh[M]; // равномерная сетка по узлам
	for (int i = 0; i < M; i++)
	{
		mesh[i] = a + i * h; // заполняем массив сетки
	}
	
	const int Mviz = 1920; // количество точек для отрисовки
	double hviz = (b - a) / (Mviz - 1); // шаг для них
	
	double X[Mviz]; // массив точек для отрисовки
	double Approx[Mviz]; // значение МНРП в этих точках
	for(int iviz = 0; iviz < Mviz; iviz++)
	{
		X[iviz] = a + iviz * hviz; // заполнение массива точек для отрисовки
	}
	
	///////////////////
	// инициализация //
	///////////////////



	// массив знаменателей
	// так как узлы на равномерной сетке, то на каждом конечном элементе
	// знаменатели будут повторяться, то есть на достаточно только N знаменателей
	double D[N]; 
	for (int i = 0; i < N; i++) // вычисление произведения знаменателя
	{
		// mesh[ki * (N - 1) + i] - i-ая точка текущего конечного элемента
		D[i] = 1;
		for (int j = 0; j < N; j++)
		{
			if (i != j) {
				D[i] *= (mesh[i] - mesh[j]);
			}
		}
	}


	// массив всех случайных точек для подсчета скалярного произведения
	// так как для нахождения МНРП нужно сначала решить СЛАУ, то нем придется хранить все точки сразу
	double random_mesh[K * L]; 
	srand(time(0)); // автоматическая рандомизиция
	for (int ki = 0; ki < K; ki++) // итерируемся ко конечным элементам
	{	
		for (int l = 0; l < L; l++) // для каждого элемента получим L точек
		{	
			// mesh[ki * (N - 1)] - начало текущего конечного элемента
			// mesh[(ki + 1) * (N - 1)] - начало следующего конечного элемента
			// random_mesh[ki * L + l] - l-ая случайная точка конечного элемента
			random_mesh[ki * L + l] = mesh[ki * (N - 1)] + (mesh[(ki + 1) * (N - 1)] - mesh[ki * (N - 1)]) * double(rand()) / (RAND_MAX);
		}
	}



	/////////////////////////
	// Нахождение векторов //
	/////////////////////////
	
	// G[i] - отвечает за i-ую функцию 
	// их количество считаем по склееным, 
	// поэтому всего их M = K * (N - 1) + 1
	// G[i][l] - значение i-ой функции на l-ой случайной точке
	// то есть G[i] - вектор значений функции на L случайных точках
	// так как у нас есть склееные по границе конечных элементов функции
	// то для G[i], где i % N - 1 == 0 (отвечает за склееные)
	// у нас определено 2 конечных элементов
	// тогда скалярный квадрат нужно считать по 2*L точкам
	// а остальные скалярные произведения
	// по пересекающимся конечным элементам

	double G[M][2 * L]; 
	double F[M][2 * L];
		
	// итерируемся по конечным элементам
	// можно рассмотреть пример
	// N = 4 K = 3
	// 0 0 0 * 0 0 * 0 0 0
	// 0 - функции определенные по одному узлу
	// * - функции определенные по двум узлам
	// то есть * граничные функции
	// в этом цикле будем считать значения всех функций в случайных точках
	for (int ki = 0; ki < K; ki++) 
	{
		for (int i = 0; i < N; i++) 
		{
			if (i == N - 1 && ki != K - 1) // условие попадания в * функцию, ведь она последняя в конечном элементе
			{
				for (int l = 0; l < L; l++)
				{	
					G[ki * (N - 1) + i][l] = 1 / D[N - 1]; // значение функции на левом конечном элементе
					G[ki * (N - 1) + i][l + L] = 1 / D[0]; // значение функции на правом конечном элементе

					// (f,g) для правой части в СЛАУ
					// так как функциия f не 0 на всем отрезке [a,b]
					// но каждая g не 0 только на одном или двух конечных элементах
					// то достаточно считать только на совпадающих конечных элементах

					F[ki * (N - 1) + i][l] = f(random_mesh[ki * L + l]); // значение f на левом конечном элементе
					F[ki * (N - 1) + i][l + L] = f(random_mesh[(ki + 1) * L + l]); // значение f на правом конечном элементе

					for (int j = 0; j < N; j++)
					{
						if (j != N - 1) // для левого конечного элемента функция построена на последнем узле этого элемента
						{
							G[ki * (N - 1) + i][l] *= (random_mesh[ki * L + l] - mesh[ki * (N - 1) + j]);
							
						}
						if (j != 0) // для правого конечного элемента функция построена на первом узле этого элемента
						{
							G[ki * (N - 1) + i][l + L] *= (random_mesh[(ki + 1) * L + l] - mesh[(ki + 1) * (N - 1) + j]);
						}
					}
				}
			}
			else if(i != 0 || ki == 0) // это отрицание (i == 0 && ki != 0) - мы не считаем эти функции, тк посчитали их уже на предыдущем отрезке
			{
				for (int l = 0; l < L; l++)
				{
					// аналогичго, но только для одного, внутреннего конечного элемента
					G[ki * (N - 1) + i][l] = 1 / D[i];
					F[ki * (N - 1) + i][l] = f(random_mesh[ki * L + l]);
					for (int j = 0; j < N; j++)
					{
						if (i != j)
						{
							G[ki * (N - 1) + i][l] *= (random_mesh[ki * L + l] - mesh[ki * (N - 1) + j]);
						}
					}
				}
			}
		}
	}

	///////////////////////////////////////////////
	// заполнение матрицы и вектора правой части //
	///////////////////////////////////////////////

	MatrixXd LAE_ = MatrixXd::Zero(M, M);
	VectorXd right_ = VectorXd::Zero(M);

	// развивая тот пример выше 
	// 0 0 0 * 0 0 * 0 0 0 - функции
	// 0 1 2 3 4 5 6 7 8 9 - их номера
	// тогда матрица будет выглядеть так
	// (0,0) (0,1) (0,2) (0,3)   0     0     0     0     0     0 
	// (1,0) (1,1) (1,2) (1,3)   0     0     0     0     0     0
	// (2,0) (2,1) (2,2) (2,3)   0     0     0     0     0     0
	// (3,0) (3,1) (3,2) (3,3) (3,4) (3,5) (3,6)   0     0     0
	//   0     0     0   (4,3) (4,4) (4,5) (4,6)   0     0     0
	//   0     0     0   (5,3) (5,4) (5,5) (5,6)   0     0     0 
	//   0     0     0   (6,3) (6,4) (6,5) (6,6) (6,7) (6,8) (6,9)
	//   0     0     0     0     0     0   (7,6) (7,7) (7,8) (7,9)
	//   0     0     0     0     0     0   (8,6) (8,7) (8,8) (8,9)    
	//   0     0     0     0     0     0   (9,6) (9,7) (9,8) (9,9)
	// 
	//

	for (int ki = 0; ki < K; ki++) // итерации по конечным элементам
	{
		for (int i = 0; i < N; i++) // итерируемся по функциям внутри каждого конечного элемента
		{
			double scalar_product_ii = 0; // (gi,gi) i в назывании роли не играет
			double scalar_product_fi = 0; // (f,gi)

			for (int j = i+1; j < N; j++) // сначала заполняем внедиагональные элементы
			{
				double scalar_product_ij = 0; // аналогично
				
				if (i == 0 && ki != 0)  // если функция узловая, то ее скалярное произведение будем считатать 
										// только по второй части точек
				{
					for (int l = 0; l < L; l++)
					{	// G[ki * (N - 1)][l + L] - узловая функция, вторая часть точек
						scalar_product_ij += G[ki * (N - 1)][l + L] * G[ki * (N - 1) + j][l];
					}
				}
				else // в противном случае считаем спокойно считаем по первым L точкам
				{
					for (int l = 0; l < L; l++)
					{
						scalar_product_ij += G[ki * (N - 1) + i][l] * G[ki * (N - 1) + j][l];
					}
				}
				LAE_(ki * (N - 1) + i, ki * (N - 1) + j) = scalar_product_ij; // заносим это значение в матрицу
				LAE_(ki * (N - 1) + j, ki * (N - 1) + i) = scalar_product_ij; // матрица Грама симметричная
			}

			// теперь строим диагональ
			// если мы строго внутри конечного элемента, на самой первой функции или на самой последней
			if ((i > 0 && i < N - 1) || (i == 0 && ki == 0) || (i == N - 1 && ki == K - 1)) 
			{// то считаем считаем по первым L точкам
				for (int l = 0; l < L; l++)
				{
					scalar_product_ii += G[ki * (N - 1) + i][l] * G[ki * (N - 1) + i][l];
					scalar_product_fi += G[ki * (N - 1) + i][l] * F[ki * (N - 1) + i][l];
				}
			}
			else 
			// если мы в конце конечного элемента, не являющимся последним
			// то считаем по 2 * L точкам
			if (i == N - 1 && ki != K - 1)
			{
				for (int l = 0; l < L; l++)
				{
					scalar_product_ii += G[ki * (N - 1) + i][l] * G[ki * (N - 1) + i][l]; 
					scalar_product_ii += G[ki * (N - 1) + i][L + l] * G[ki * (N - 1) + i][L + l];
					scalar_product_fi += G[ki * (N - 1) + i][l] * F[ki * (N - 1) + i][l];
					scalar_product_fi += G[ki * (N - 1) + i][L + l] * F[ki * (N - 1) + i][L + l];
				}
			}
			else if (i == 0 && ki != 0) // тк уже посчитали скалярный квадрат граничной функции на предыдущем элементе, то пропускаем
			{
				continue;
			}
			

			LAE_(ki * (N - 1) + i, ki * (N - 1) + i) = scalar_product_ii; // заносим значение в матрицу
			right_(ki* (N - 1) + i) = scalar_product_fi; // и в правую часть СЛАУ
		}
	}

	//////////////////
	// решение СЛАУ //
	//////////////////

	VectorXd c = LAE_.colPivHouseholderQr().solve(right_); // решаем СЛАУ

	/////////////////////////////
	// вычисление погрешностей //
	/////////////////////////////
	
	// абсолютная погрешность на случайных точках
	double er1 = 0, er2 = 0, erinf = 0; 
	// относительная погрешость = er / fr
	double fr1 = 0, fr2 = 0, frinf = 0;

	for (int il = 0, ki = 0; il < K * L ; il++) // находим аппроксимацию в точках для отображения
	{
		if (il % L == 0 && il != 0 && il != K * L - 1) // теперь итерации по всем точкам, поэтому нужно следить за текущим конечным элементом
		{
			ki++;
		}
		double tmp = 0;
		double ftmp = f(random_mesh[il]);
		for (int i = 0; i < N; i++)
		{
			double g = 1 / D[i]; // считаем значение базисной функции в точке
			for (int j = 0; j < N; j++)
			{
				if (i != j)
				{
					g *= (random_mesh[il] - mesh[ki * (N - 1) + j]);
				}
			}
			tmp += c(ki * (N - 1) + i) * g; // и умножаем на нужный множитель
		}
		tmp -= ftmp;
		er1 += abs(tmp);
		er2 += tmp * tmp;
		if (abs(tmp) > erinf) {
			erinf = abs(tmp);
		}

		fr1 += abs(ftmp);
		fr2 += ftmp * ftmp;
		if (abs(ftmp) > frinf) {
			frinf = abs(ftmp);
		}

	}

	er2 = sqrt(er2);
	fr2 = sqrt(fr2);

	// абсолютная погрешность на равномерной сетке с шагом h/100
	double e1 = 0, e2 = 0, einf = 0;
	// относительная погрешость = e / f
	double f1 = 0, f2 = 0, finf = 0;

	for (int meshi = 0, ki = 0; meshi < M; meshi++) // итерируемся по конечным элементам
	{
		if (meshi > (ki + 1) * (N - 1)) // теперь итерации по всем точкам, поэтому нужно следить за текущим конечным элементом
		{
			ki++;
		}
		double h100 = h / 100;
		for (int hi = 0; hi < 100; hi++) 
		{
			double tmp = 0;
			double ftmp = f(mesh[meshi] + hi * h100);
			for (int i = 0; i < N; i++)
			{
				double g = 1 / D[i]; // считаем значение базисной функции в точке
				for (int j = 0; j < N; j++)
				{
					if (i != j)
					{
						g *= (mesh[meshi] + hi * h100 - mesh[ki * (N - 1) + j]);
					}
				}
				tmp += c(ki * (N - 1) + i) * g; // и умножаем на нужный множитель
			}

			tmp -= ftmp;
			e1 += abs(tmp);
			e2 += tmp * tmp;
			if (abs(tmp) > einf) {
				einf = abs(tmp);
			}
						
			f1 += abs(ftmp);
			f2 += ftmp * ftmp;
			if (abs(ftmp) > finf) {
				finf = abs(ftmp);
			}
		}
	}




	for (int iviz = 0, ki = 0; iviz < Mviz; iviz++) // находим аппроксимацию в точках для отображения
	{
		if (X[iviz] > mesh[(ki + 1) * (N - 1)]) // теперь итерации по всем точкам, поэтому нужно следить за текущим конечным элементом
		{
			ki++;
		}
		Approx[iviz] = 0; // инициализируем сумму нулем
		for (int i = 0; i < N; i++)
		{
			double gviz = 1 / D[i]; // считаем значение базисной функции в точке
			for (int j = 0; j < N; j++)
			{
				if (i != j)
				{
					gviz *= (X[iviz] - mesh[ki * (N - 1) + j]);
				}
			}
			Approx[iviz] += c(ki * (N - 1) + i) * gviz; // и умножаем на нужный множитель
		}

	}


	////////////////////
	// запись в файлы //
	////////////////////


	std::ofstream ResudialFile; // файл параметров - в нем a,b и все нормы
	ResudialFile.open("Resudial.txt");
	ResudialFile << std::setiosflags(std::ios_base::scientific);
	ResudialFile << "|----------------|--------------|--------------|--------------|" << std::endl;
	ResudialFile << "|      mesh      |    ||*||1    |    ||*||2    |   ||*||inf   |" << std::endl;
	ResudialFile << "|----------------|--------------|--------------|--------------|" << std::endl;
	
	ResudialFile << "|  h / 100 | abs | "
				 << e1 << " | " 
				 << e2 << " | "		
				 << einf << " |" << std::endl;
	ResudialFile << "|----------|-----|--------------|--------------|--------------|" << std::endl;

	ResudialFile << "|          | rel | "
				 << e1 / f1 << " | " 
				 << e2 / f2 << " | " 
				 << einf / finf << " |" << std::endl;
	ResudialFile << "|----------|-----|--------------|--------------|--------------|" << std::endl;

	ResudialFile << "|  random  | abs | "
				 << er1 << " | " 
				 << er2 << " | " 
				 << erinf << " |" << std::endl;
	ResudialFile << "|----------|-----|--------------|--------------|--------------|" << std::endl;

	ResudialFile << "|          | rel | "
				 << er1 / fr1 << " | " 
				 << er2 / fr2 << " | "
				 << erinf / frinf << " |" << std::endl;
	ResudialFile.close();
	

	std::ofstream ParamsFile; // файл параметров - в нем a,b и все нормы
	ParamsFile.open("Params.txt");
	ParamsFile << a << ", " << b << ", "
		<< e1 << ", " << e2 << ", " << einf << ", "
		<< e1 / f1 << ", " << e2 / f2 << ", " << einf / finf << ", "
		<< er1 << ", " << er2 << ", " << erinf << ", "
		<< er1 / fr1 << ", " << er2 / fr2 << ", " << erinf / frinf << ", "
		<< std::endl;
	ParamsFile.close();

	std::ofstream meshFile, FmeshFile; // файлы точек интерполяции и значения функции в этих точках - для выделения красным
	meshFile.open("mesh.txt");
	FmeshFile.open("Fmesh.txt");
	for (int i = 0; i < M - 1; i++) 
	{
		meshFile << mesh[i] << ", ";
		FmeshFile << f(mesh[i]) << ", ";
	}
	meshFile << mesh[M - 1] << std::endl;
	FmeshFile << f(mesh[M - 1]) << std::endl;
	meshFile.close();
	FmeshFile.close();

	std::ofstream XFile, ApproxFile, FFile; // файлы точек построения графиков
	XFile.open("X.txt"); // Точки X
	ApproxFile.open("Approx.txt"); // Значения полинома Лагранжа в этих точках
	FFile.open("F.txt"); // Значения функции в этих точках
	for (int i = 0; i < Mviz - 1; i++) 
	{
		XFile << X[i] << ", ";
		FFile << f(X[i]) << ", ";
		ApproxFile << Approx[i] << ", ";
	}
	XFile << X[Mviz - 1] << std::endl;
	FFile << f(X[Mviz - 1]) << std::endl;
	ApproxFile << Approx[Mviz - 1] << std::endl;
	XFile.close();
	ApproxFile.close();
	FFile.close();


	std::ofstream KFile, KFFile;
	KFile.open("K.txt"); // Значения функции в этих точках
	KFFile.open("KF.txt"); // Значения функции в этих точках
	for (int ki = 0; ki < K - 1; ki++) 
	{
		KFile << mesh[ki * (N - 1)] << ", ";
		KFFile << f(mesh[ki * (N - 1)]) << ", ";
	}
	KFile << mesh[M - 1] << std::endl;
	KFFile << f(mesh[M - 1]) << std::endl;
	KFile.close();
	KFFile.close();


	std::system("python plot.py"); // эта команда вызывает командную строку и включает питоновскую часть задачи
	std::system("del /s /q Params.txt X.txt F.txt Approx.txt mesh.txt Fmesh.txt K.txt KF.txt"); 
	
	return 0;
}