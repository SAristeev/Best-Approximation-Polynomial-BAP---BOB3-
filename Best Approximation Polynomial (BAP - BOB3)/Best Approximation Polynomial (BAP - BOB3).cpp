#define _CRT_SECURE_NO_WARNINGS // для fopen в visual studio
#include <cmath>
#include <cstdio>
#include <Dense>


using Eigen::MatrixXd;
using Eigen::VectorXd;

double f(double x) 
{
	return sin(x);
}

int main()
{
	double a = -2, b = 2; // начало и конец отрезка

	const int K = 10; // количество конечных элементов
	const int N = 6; // количество узлов на 1 конечном элементе
	const int L = 40; // количество случайных точек
	const int M_ = K * N; // количество базисных (склееных) функций

	const int M = K * (N - 1) + 1; // количество базисных (склееных) функций, оно же количество узлов
	double h = (b - a) / (M - 1); // шаг по равномерной сетке

	double mesh[M]; // равномерная сетка по узлам
	for (int i = 0; i < M; i++)
	{
		mesh[i] = a + i * h; // заполняем массив сетки
	}
	
	const int Mviz = 1920; // количество точек для отрисовки
	double hviz = (b - a) / (Mviz - 1); // шаг для них
	
	double X[Mviz]; // массив точек для отрисовки
	double Approx[Mviz]; // значение МНРП в этих точках
	for(int iviz = 0; iviz < Mviz; iviz++)
	{
		X[iviz] = a + iviz * hviz; // заполнение массива точек для отрисовки
	}
	
	///////////////////
	// инициализация //
	///////////////////



	// массив знаменателей
	// так как узлы на равномерной сетке, то на каждом конечном элементе
	// знаменатели будут повторяться, то есть на достаточно только N знаменателей
	double D[N]; 
	for (int i = 0; i < N; i++) // вычисление произведения знаменателя
	{
		// mesh[ki * (N - 1) + i] - i-ая точка текущего конечного элемента
		D[i] = 1;
		for (int j = 0; j < N; j++)
		{
			if (i != j) {
				D[i] *= (mesh[i] - mesh[j]);
			}
		}
	}


	// массив всех случайных точек для подсчета скалярного произведения
	// так как для нахождения МНРП нужно сначала решить СЛАУ, то нем придется хранить все точки сразу
	double random_mesh[K * L]; 
	srand(time(0)); // автоматическая рандомизиция
	for (int ki = 0; ki < K; ki++) // итерируемся ко конечным элементам
	{	
		for (int l = 0; l < L; l++) // для каждого элемента получим L точек
		{	
			// mesh[ki * (N - 1)] - начало текущего конечного элемента
			// mesh[(ki + 1) * (N - 1)] - начало следующего конечного элемента
			// random_mesh[ki * L + l] - l-ая случайная точка конечного элемента
			random_mesh[ki * L + l] = mesh[ki * (N - 1)] + (mesh[(ki + 1) * (N - 1)] - mesh[ki * (N - 1)]) * double(rand()) / (RAND_MAX);
		}
	}



	/////////////////////////
	// Нахождение векторов //
	/////////////////////////
	
	// G[i] - отвечает за i-ую функцию 
	// их количество считаем по склееным, 
	// поэтому всего их M = K * (N - 1) + 1
	// G[i][l] - значение i-ой функции на l-ой случайной точке
	// то есть G[i] - вектор значений функции на L случайных точках
	// так как у нас есть склееные по границе конечных элементов функции
	// то для G[i], где i % N - 1 == 0 (отвечает за склееные)
	// у нас определено 2 конечных элементов
	// тогда скалярный квадрат нужно считать по 2*L точкам
	// а остальные скалярные произведения
	// по пересекающимся конечным элементам

	double G[M][2 * L]; 
	double F[M][2 * L];
		
	// итерируемся по конечным элементам
	// можно рассмотреть пример
	// N = 4 K = 3
	// 0 0 0 * 0 0 * 0 0 0
	// 0 - функции определенные по одному узлу
	// * - функции определенные по двум узлам
	// то есть * граничные функции
	// в этом цикле будем считать значения всех функций в случайных точках
	for (int ki = 0; ki < K; ki++) 
	{
		for (int i = 0; i < N; i++) 
		{
			if (i == N - 1 && ki != K - 1) // условие попадания в * функцию, ведь она последняя в конечном элементе
			{
				for (int l = 0; l < L; l++)
				{	
					G[ki * (N - 1) + i][l] = 1 / D[N - 1]; // значение функции на левом конечном элементе
					G[ki * (N - 1) + i][l + L] = 1 / D[0]; // значение функции на правом конечном элементе

					// (f,g) для правой части в СЛАУ
					// так как функциия f не 0 на всем отрезке [a,b]
					// но каждая g не 0 только на одном или двух конечных элементах
					// то достаточно считать только на совпадающих конечных элементах

					F[ki * (N - 1) + i][l] = f(random_mesh[ki * L + l]); // значение f на левом конечном элементе
					F[ki * (N - 1) + i][l + L] = f(random_mesh[(ki + 1) * L + l]); // значение f на правом конечном элементе

					for (int j = 0; j < N; j++)
					{
						if (j != N - 1) // для левого конечного элемента функция построена на последнем узле этого элемента
						{
							G[ki * (N - 1) + i][l] *= (random_mesh[ki * L + l] - mesh[ki * (N - 1) + j]);
							
						}
						if (j != 0) // для правого конечного элемента функция построена на первом узле этого элемента
						{
							G[ki * (N - 1) + i][l + L] *= (random_mesh[(ki + 1) * L + l] - mesh[(ki + 1) * (N - 1) + j]);
						}
					}
				}
			}
			else if(i != 0 || ki == 0) // это отрицание (i == 0 && ki != 0) - мы не считаем эти функции, тк посчитали их уже на предыдущем отрезке
			{
				for (int l = 0; l < L; l++)
				{
					// аналогичго, но только для одного, внутреннего конечного элемента
					G[ki * (N - 1) + i][l] = 1 / D[i];
					F[ki * (N - 1) + i][l] = f(random_mesh[ki * L + l]);
					for (int j = 0; j < N; j++)
					{
						if (i != j)
						{
							G[ki * (N - 1) + i][l] *= (random_mesh[ki * L + l] - mesh[ki * (N - 1) + j]);
						}
					}
				}
			}
		}
	}

	///////////////////////////////////////////////
	// заполнение матрицы и вектора правой части //
	///////////////////////////////////////////////

	MatrixXd LAE_ = MatrixXd::Zero(M, M);
	VectorXd right_ = VectorXd::Zero(M);

	// развивая тот пример выше 
	// 0 0 0 * 0 0 * 0 0 0 - функции
	// 0 1 2 3 4 5 6 7 8 9 - их номера
	// тогда матрица будет выглядеть так
	// (0,0) (0,1) (0,2) (0,3)   0     0     0     0     0     0 
	// (1,0) (1,1) (1,2) (1,3)   0     0     0     0     0     0
	// (2,0) (2,1) (2,2) (2,3)   0     0     0     0     0     0
	// (3,0) (3,1) (3,2) (3,3) (3,4) (3,5) (3,6)   0     0     0
	//   0     0     0   (4,3) (4,4) (4,5) (4,6)   0     0     0
	//   0     0     0   (5,3) (5,4) (5,5) (5,6)   0     0     0 
	//   0     0     0   (6,3) (6,4) (6,5) (6,6) (6,7) (6,8) (6,9)
	//   0     0     0     0     0     0   (7,6) (7,7) (7,8) (7,9)
	//   0     0     0     0     0     0   (8,6) (8,7) (8,8) (8,9)    
	//   0     0     0     0     0     0   (9,6) (9,7) (9,8) (9,9)
	// 
	//

	for (int ki = 0; ki < K; ki++) // итерации по конечным элементам
	{
		for (int i = 0; i < N; i++) // итерируемся по функциям внутри каждого конечного элемента
		{
			double scalar_product_ii = 0; // (gi,gi) i в назывании роли не играет
			double scalar_product_fi = 0; // (f,gi)

			for (int j = i+1; j < N; j++) // сначала заполняем внедиагональные элементы
			{
				double scalar_product_ij = 0; // аналогично
				
				if (i == 0 && ki != 0)  // если функция узловая, то ее скалярное произведение будем считатать 
										// только по второй части точек
				{
					for (int l = 0; l < L; l++)
					{	// G[ki * (N - 1)][l + L] - узловая функция, вторая часть точек
						scalar_product_ij += G[ki * (N - 1)][l + L] * G[ki * (N - 1) + j][l];
					}
				}
				else // в противном случае считаем спокойно считаем по первым L точкам
				{
					for (int l = 0; l < L; l++)
					{
						scalar_product_ij += G[ki * (N - 1) + i][l] * G[ki * (N - 1) + j][l];
					}
				}
				LAE_(ki * (N - 1) + i, ki * (N - 1) + j) = scalar_product_ij; // заносим это значение в матрицу
				LAE_(ki * (N - 1) + j, ki * (N - 1) + i) = scalar_product_ij; // матрица Грама симметричная
			}

			// теперь строим диагональ
			// если мы строго внутри конечного элемента, на самой первой функции или на самой последней
			if ((i > 0 && i < N - 1) || (i == 0 && ki == 0) || (i == N - 1 && ki == K - 1)) 
			{// то считаем считаем по первым L точкам
				for (int l = 0; l < L; l++)
				{
					scalar_product_ii += G[ki * (N - 1) + i][l] * G[ki * (N - 1) + i][l];
					scalar_product_fi += G[ki * (N - 1) + i][l] * F[ki * (N - 1) + i][l];
				}
			}
			else 
			// если мы в конце конечного элемента, не являющимся последним
			// то считаем по 2 * L точкам
			if (i == N - 1 && ki != K - 1)
			{
				for (int l = 0; l < L; l++)
				{
					scalar_product_ii += G[ki * (N - 1) + i][l] * G[ki * (N - 1) + i][l]; 
					scalar_product_ii += G[ki * (N - 1) + i][L + l] * G[ki * (N - 1) + i][L + l];
					scalar_product_fi += G[ki * (N - 1) + i][l] * F[ki * (N - 1) + i][l];
					scalar_product_fi += G[ki * (N - 1) + i][L + l] * F[ki * (N - 1) + i][L + l];
				}
			}
			else if (i == 0 && ki != 0) // тк уже посчитали скалярный квадрат граничной функции на предыдущем элементе, то пропускаем
			{
				continue;
			}
			

			LAE_(ki * (N - 1) + i, ki * (N - 1) + i) = scalar_product_ii; // заносим значение в матрицу
			right_(ki* (N - 1) + i) = scalar_product_fi; // и в правую часть СЛАУ
		}
	}

	//////////////////
	// решение СЛАУ //
	//////////////////

	VectorXd c = LAE_.colPivHouseholderQr().solve(right_); // решаем СЛАУ

	/////////////////////////////
	// вычисление погрешностей //
	/////////////////////////////
	
	// абсолютная погрешность на случайных точках
	double er1 = 0, er2 = 0, erinf = 0; 
	// относительная погрешость = er / fr
	double fr1 = 0, fr2 = 0, frinf = 0;

	for (int il = 0, ki = 0; il < K * L ; il++) // находим аппроксимацию в точках для отображения
	{
		if (il % L == 0 && il != 0 && il != K * L - 1) // теперь итерации по всем точкам, поэтому нужно следить за текущим конечным элементом
		{
			ki++;
		}
		double tmp = 0;
		double ftmp = f(random_mesh[il]);
		for (int i = 0; i < N; i++)
		{
			double g = 1 / D[i]; // считаем значение базисной функции в точке
			for (int j = 0; j < N; j++)
			{
				if (i != j)
				{
					g *= (random_mesh[il] - mesh[ki * (N - 1) + j]);
				}
			}
			tmp += c(ki * (N - 1) + i) * g; // и умножаем на нужный множитель
		}
		tmp -= ftmp;
		er1 += abs(tmp);
		er2 += tmp * tmp;
		if (abs(tmp) > erinf) {
			erinf = abs(tmp);
		}

		fr1 += abs(ftmp);
		fr2 += ftmp * ftmp;
		if (abs(ftmp) > frinf) {
			frinf = abs(ftmp);
		}

	}

	er2 = sqrt(er2);
	fr2 = sqrt(fr2);

	// абсолютная погрешность на равномерной сетке с шагом h/100
	double e1 = 0, e2 = 0, einf = 0;
	// относительная погрешость = e / f
	double f1 = 0, f2 = 0, finf = 0;

	for (int meshi = 0, ki = 0; meshi < M; meshi++) // итерируемся по конечным элементам
	{
		if (meshi > (ki + 1) * (N - 1)) // теперь итерации по всем точкам, поэтому нужно следить за текущим конечным элементом
		{
			ki++;
		}
		double h100 = h / 100;
		for (int hi = 0; hi < 100; hi++) 
		{
			double tmp = 0;
			double ftmp = f(mesh[meshi] + hi * h100);
			for (int i = 0; i < N; i++)
			{
				double g = 1 / D[i]; // считаем значение базисной функции в точке
				for (int j = 0; j < N; j++)
				{
					if (i != j)
					{
						g *= (mesh[meshi] + hi * h100 - mesh[ki * (N - 1) + j]);
					}
				}
				tmp += c(ki * (N - 1) + i) * g; // и умножаем на нужный множитель
			}

			tmp -= ftmp;
			e1 += abs(tmp);
			e2 += tmp * tmp;
			if (abs(tmp) > einf) {
				einf = abs(tmp);
			}
						
			f1 += abs(ftmp);
			f2 += ftmp * ftmp;
			if (abs(ftmp) > finf) {
				finf = abs(ftmp);
			}
		}
	}




	for (int iviz = 0, ki = 0; iviz < Mviz; iviz++) // находим аппроксимацию в точках для отображения
	{
		if (X[iviz] > mesh[(ki + 1) * (N - 1)]) // теперь итерации по всем точкам, поэтому нужно следить за текущим конечным элементом
		{
			ki++;
		}
		Approx[iviz] = 0; // инициализируем сумму нулем
		for (int i = 0; i < N; i++)
		{
			double gviz = 1 / D[i]; // считаем значение базисной функции в точке
			for (int j = 0; j < N; j++)
			{
				if (i != j)
				{
					gviz *= (X[iviz] - mesh[ki * (N - 1) + j]);
				}
			}
			Approx[iviz] += c(ki * (N - 1) + i) * gviz; // и умножаем на нужный множитель
		}

	}


	////////////////////
	// запись в файлы //
	////////////////////


	FILE* ResudialFile; // файл погрешностей - создает txt файл с таблицей
	ResudialFile = fopen("Resudial.txt", "w");

	fprintf(ResudialFile, "|----------------|----------------|----------------|----------------|\n");
	fprintf(ResudialFile, "|      mesh      |     ||*||1     |     ||*||2     |    ||*||inf    |\n");
	fprintf(ResudialFile, "|----------------|----------------|----------------|----------------|\n");
	fprintf(ResudialFile, "|  h / 100 | abs | %14.8e | %14.8e | %14.8e |\n", e1, e2, einf);
	fprintf(ResudialFile, "|          | rel | %14.8e | %14.8e | %14.8e |\n", e1 / f1, e2 / f2, einf / finf);
	fprintf(ResudialFile, "|----------|-----|----------------|----------------|----------------|\n");
	fprintf(ResudialFile, "|  random  | abs | %14.8e | %14.8e | %14.8e |\n", er1, er2, erinf);
	fprintf(ResudialFile, "|          | rel | %14.8e | %14.8e | %14.8e |\n", er1 / fr1, er2 / fr2, erinf / frinf);
	fprintf(ResudialFile, "|----------|-----|----------------|----------------|----------------|\n");
	fclose(ResudialFile);

	FILE *ParamsFile; // файл параметров - в нем a,b и все нормы
	ParamsFile = fopen("Params.txt","w");
	fprintf(ParamsFile, "%f, %f", a, b);
	fclose(ParamsFile);

	FILE *meshFile, *FmeshFile; // файлы точек интерполяции и значения функции в этих точках - для выделения красным
	meshFile = fopen("mesh.txt","w");
	FmeshFile = fopen("Fmesh.txt","w");
	for (int i = 0; i < M - 1; i++) 
	{
		fprintf(meshFile,"%f, ", mesh[i]);
		fprintf(FmeshFile, "%f, ", f(mesh[i]));
	}
	fprintf(meshFile, "%f\n", mesh[M - 1]);
	fprintf(FmeshFile, "%f\n", f(mesh[M - 1]));
	fclose(meshFile);
	fclose(FmeshFile);

	FILE *XFile, *ApproxFile, *FFile; // файлы точек построения графиков
	XFile = fopen("X.txt", "w"); // Точки X
	ApproxFile = fopen("Approx.txt", "w"); // Значения полинома Лагранжа в этих точках
	FFile = fopen("F.txt","w"); // Значения функции в этих точках
	for (int i = 0; i < Mviz - 1; i++) 
	{
		fprintf(XFile, "%f, ", X[i]);
		fprintf(FFile,"%f, ", f(X[i]));
		fprintf(ApproxFile, "%f, ", Approx[i]);
	}
	fprintf(XFile, "%f\n", X[Mviz - 1]);
	fprintf(FFile, "%f\n", f(X[Mviz - 1]));
	fprintf(ApproxFile, "%f\n", Approx[Mviz - 1]);
	fclose(XFile);
	fclose(ApproxFile);
	fclose(FFile);


	FILE *KFile, *KFFile;
	KFile = fopen("K.txt", "w"); // Значения функции в этих точках
	KFFile = fopen("KF.txt", "w"); // Значения функции в этих точках
	for (int ki = 0; ki < K - 1; ki++) 
	{
		fprintf(KFile, "%f, ", mesh[ki * (N - 1)]);
		fprintf(KFFile, "%f, ", f(mesh[ki * (N - 1)]));
	}
	fprintf(KFile, "%f\n", mesh[M - 1]);
	fprintf(KFFile, "%f\n", f(mesh[M - 1]));
	fclose(KFile);
	fclose(KFFile);


	std::system("python plot.py"); // эта команда вызывает командную строку и включает питоновскую часть задачи
	std::system("del /s /q Params.txt X.txt F.txt Approx.txt mesh.txt Fmesh.txt K.txt KF.txt"); 
	
	return 0;
}